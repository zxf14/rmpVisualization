'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _domLib = require('dom-lib');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function findIndexOf(arr, cb) {
    var idx = -1;
    arr.some(function (d, i) {
        if (cb(d, i)) {
            idx = i;
            return true;
        }
    });
    return idx;
}

function findContainer(data, modal) {
    return findIndexOf(data, function (d) {
        return d.modals.indexOf(modal) !== -1;
    });
}

/**
 * Proper state managment for containers and the modals in those containers.
 *
 * @internal Used by the Modal to ensure proper styling of containers.
 */

var ModalManager = function () {
    function ModalManager() {
        var hideSiblingNodes = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];

        _classCallCheck(this, ModalManager);

        this.hideSiblingNodes = hideSiblingNodes;
        this.modals = [];
        this.containers = [];
        this.data = [];
    }

    _createClass(ModalManager, [{
        key: 'add',
        value: function add(modal, container, className) {
            var modalIdx = this.modals.indexOf(modal);
            var containerIdx = this.containers.indexOf(container);

            if (modalIdx !== -1) {
                return modalIdx;
            }

            modalIdx = this.modals.length;
            this.modals.push(modal);

            if (containerIdx !== -1) {
                this.data[containerIdx].modals.push(modal);
                return modalIdx;
            }

            var data = {
                modals: [modal],
                //right now only the first modal of a container will have its classes applied
                classes: className ? className.split(/\s+/) : [],
                //we are only interested in the actual `style` here becasue we will override it
                style: {
                    overflow: container.style.overflow,
                    paddingRight: container.style.paddingRight
                }
            };

            var style = {
                overflow: 'hidden'
            };

            data.overflowing = (0, _domLib.isOverflowing)(container);

            if (data.overflowing) {
                // use computed style, here to get the real padding
                // to add our scrollbar width
                style.paddingRight = parseInt((0, _domLib.addStyle)(container, 'paddingRight') || 0, 10) + (0, _domLib.getScrollbarSize)() + 'px';
            }

            (0, _domLib.addStyle)(container, style);

            data.classes.forEach(_domLib.addClass.bind(null, container));

            this.containers.push(container);
            this.data.push(data);

            return modalIdx;
        }
    }, {
        key: 'remove',
        value: function remove(modal) {

            var modalIdx = this.modals.indexOf(modal);

            if (modalIdx === -1) {
                return;
            }

            var containerIdx = findContainer(this.data, modal);

            var data = this.data[containerIdx];
            var container = this.containers[containerIdx];

            data.modals.splice(data.modals.indexOf(modal), 1);

            this.modals.splice(modalIdx, 1);

            // if that was the last modal in a container,
            // clean up the container stylinhg.
            if (data.modals.length === 0) {
                Object.keys(data.style).forEach(function (key) {
                    return container.style[key] = data.style[key];
                });

                data.classes.forEach(_domLib.removeClass.bind(null, container));

                this.containers.splice(containerIdx, 1);
                this.data.splice(containerIdx, 1);
            }
        }
    }, {
        key: 'isTopModal',
        value: function isTopModal(modal) {
            return !!this.modals.length && this.modals[this.modals.length - 1] === modal;
        }
    }]);

    return ModalManager;
}();

exports.default = ModalManager;