'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _domLib = require('dom-lib');

var _Overlay = require('./fixtures/Overlay');

var _Overlay2 = _interopRequireDefault(_Overlay);

var _lodash = require('lodash');

var _createChainedFunction = require('./utils/createChainedFunction');

var _createChainedFunction2 = _interopRequireDefault(_createChainedFunction);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Check if value one is inside or equal to the of value
 *
 * @param {string} one
 * @param {string|array} of
 * @returns {boolean}
 */
function isOneOf(one, of) {
    if (Array.isArray(of)) {
        return of.indexOf(one) >= 0;
    }
    return one === of;
}

function isNullOrUndefinded(k) {
    return (0, _lodash.isNull)(k) || (0, _lodash.isUndefined)(k);
}

var Whisper = _react2.default.createClass({
    displayName: 'Whisper',


    propTypes: _extends({}, _Overlay2.default.propTypes, {

        /**
         * Specify which action or actions trigger Overlay visibility
         */
        trigger: _react2.default.PropTypes.oneOfType([_react2.default.PropTypes.oneOf(['click', 'hover', 'focus']), _react2.default.PropTypes.arrayOf(_react2.default.PropTypes.oneOf(['click', 'hover', 'focus']))]),

        /**
         * A millisecond delay amount to show and hide the Overlay once triggered
         */
        delay: _react2.default.PropTypes.number,
        /**
         * A millisecond delay amount before showing the Overlay once triggered.
         */
        delayShow: _react2.default.PropTypes.number,
        /**
         * A millisecond delay amount before hiding the Overlay once triggered.
         */
        delayHide: _react2.default.PropTypes.number,

        /**
         * The initial visibility state of the Overlay, for more nuanced visibility controll consider
         * using the Overlay component directly.
         */
        defaultOverlayShown: _react2.default.PropTypes.bool,

        /**
         * An element or text to speaker next to the target.
         */
        speaker: _react2.default.PropTypes.node.isRequired,
        onBlur: _react2.default.PropTypes.func,
        onClick: _react2.default.PropTypes.func,
        onFocus: _react2.default.PropTypes.func,
        onMouseLeave: _react2.default.PropTypes.func,

        // override specific speaker props
        target: function target() {},
        onHide: function onHide() {},
        show: function show() {}
    }),

    getDefaultProps: function getDefaultProps() {
        return {
            defaultOverlayShown: false,
            trigger: ['hover', 'focus'],
            rootClose: true
        };
    },
    getInitialState: function getInitialState() {
        return { isOverlayShown: this.props.defaultOverlayShown };
    },
    show: function show() {
        this.setState({ isOverlayShown: true });
    },
    hide: function hide() {
        this.setState({ isOverlayShown: false });
    },
    toggle: function toggle() {
        if (this.state.isOverlayShown) {
            this.hide();
        } else {
            this.show();
        }
    },
    componentWillMount: function componentWillMount() {
        this.handleMouseOver = this.handleMouseOverOut.bind(null, this.handleDelayedShow);
        this.handleMouseOut = this.handleMouseOverOut.bind(null, this.handleDelayedHide);
    },
    componentDidMount: function componentDidMount() {
        this._mountNode = document.createElement('div');
        this.renderOverlay();
    },
    renderOverlay: function renderOverlay() {
        _reactDom2.default.unstable_renderSubtreeIntoContainer(this, this._speaker, this._mountNode);
    },
    componentWillUnmount: function componentWillUnmount() {
        _reactDom2.default.unmountComponentAtNode(this._mountNode);
        this._mountNode = null;
        clearTimeout(this._hoverShowDelay);
        clearTimeout(this._hoverHideDelay);
    },
    componentDidUpdate: function componentDidUpdate() {
        if (this._mountNode) {
            this.renderOverlay();
        }
    },
    getOverlayTarget: function getOverlayTarget() {
        return _reactDom2.default.findDOMNode(this);
    },
    getOverlay: function getOverlay() {
        var speakerProps = _extends({}, (0, _lodash.pick)(this.props, Object.keys(_Overlay2.default.propTypes)), {
            show: this.state.isOverlayShown,
            onHide: this.hide,
            target: this.getOverlayTarget,
            onExit: this.props.onExit,
            onExiting: this.props.onExiting,
            onExited: this.props.onExited,
            onEnter: this.props.onEnter,
            onEntering: this.props.onEntering,
            onEntered: this.props.onEntered
        });

        var speaker = (0, _react.cloneElement)(this.props.speaker, {
            placement: speakerProps.placement,
            container: speakerProps.container
        });

        return _react2.default.createElement(
            _Overlay2.default,
            speakerProps,
            speaker
        );
    },
    render: function render() {
        var trigger = _react2.default.Children.only(this.props.children);
        var triggerProps = trigger.props;

        var props = {
            'aria-describedby': this.props.speaker.props.id
        };

        // create in render otherwise owner is lost...
        this._speaker = this.getOverlay();

        props.onClick = (0, _createChainedFunction2.default)(triggerProps.onClick, this.props.onClick);

        if (isOneOf('click', this.props.trigger)) {
            props.onClick = (0, _createChainedFunction2.default)(this.toggle, props.onClick);
        }

        if (isOneOf('hover', this.props.trigger)) {
            new Error(!(this.props.trigger === 'hover'), '[suite] Specifying only the `"hover"` trigger limits the visibilty of the speaker to just mouse users. ' + 'Consider also including the `"focus"` trigger so that touch and keyboard only users can see the speaker as well.');

            props.onMouseOver = (0, _createChainedFunction2.default)(this.handleMouseOver, this.props.onMouseOver, triggerProps.onMouseOver);
            props.onMouseOut = (0, _createChainedFunction2.default)(this.handleMouseOut, this.props.onMouseOut, triggerProps.onMouseOut);
        }

        if (isOneOf('focus', this.props.trigger)) {
            props.onFocus = (0, _createChainedFunction2.default)(this.handleDelayedShow, this.props.onFocus, triggerProps.onFocus);
            props.onBlur = (0, _createChainedFunction2.default)(this.handleDelayedHide, this.props.onBlur, triggerProps.onBlur);
        }

        return (0, _react.cloneElement)(trigger, props);
    },
    handleDelayedShow: function handleDelayedShow() {
        var _this = this;

        if (!isNullOrUndefinded(this._hoverHideDelay)) {
            clearTimeout(this._hoverHideDelay);
            this._hoverHideDelay = null;
            return;
        }

        if (this.state.isOverlayShown || !isNullOrUndefinded(this._hoverShowDelay)) {
            return;
        }

        var delay = !isNullOrUndefinded(this.props.delayShow) ? this.props.delayShow : this.props.delay;

        if (!delay) {
            this.show();
            return;
        }

        this._hoverShowDelay = setTimeout(function () {
            _this._hoverShowDelay = null;
            _this.show();
        }, delay);
    },
    handleDelayedHide: function handleDelayedHide() {
        var _this2 = this;

        if (!isNullOrUndefinded(this._hoverShowDelay)) {
            clearTimeout(this._hoverShowDelay);
            this._hoverShowDelay = null;
            return;
        }

        if (!this.state.isOverlayShown || !isNullOrUndefinded(this._hoverHideDelay)) {
            return;
        }

        var delay = !isNullOrUndefinded(this.props.delayHide) ? this.props.delayHide : this.props.delay;

        if (!delay) {
            this.hide();
            return;
        }

        this._hoverHideDelay = setTimeout(function () {
            _this2._hoverHideDelay = null;
            _this2.hide();
        }, delay);
    },


    // Simple implementation of mouseEnter and mouseLeave.
    // React's built version is broken: https://github.com/facebook/react/issues/4251
    // for cases when the trigger is disabled and mouseOut/Over can cause flicker moving
    // from one child element to another.
    handleMouseOverOut: function handleMouseOverOut(handler, e) {
        var target = e.currentTarget;
        var related = e.relatedTarget || e.nativeEvent.toElement;
        if (!related || related !== target && !(0, _domLib.contains)(target, related)) {
            handler(e);
        }
    }
});

exports.default = Whisper;